<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>control.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#applyAncToEndpointByIp">applyAncToEndpointByIp</a></li><li data-type='method'><a href="Client.html#applyAncToEndpointByMac">applyAncToEndpointByMac</a></li><li data-type='method'><a href="Client.html#clearAncFromEndpointByIp">clearAncFromEndpointByIp</a></li><li data-type='method'><a href="Client.html#clearAncFromEndpointByMac">clearAncFromEndpointByMac</a></li><li data-type='method'><a href="Client.html#connectToBroker">connectToBroker</a></li><li data-type='method'><a href="Client.html#createAncPolicy">createAncPolicy</a></li><li data-type='method'><a href="Client.html#createEndpointAssetPublisher">createEndpointAssetPublisher</a></li><li data-type='method'><a href="Client.html#deleteAncPolicy">deleteAncPolicy</a></li><li data-type='method'><a href="Client.html#getAncEndpointByMac">getAncEndpointByMac</a></li><li data-type='method'><a href="Client.html#getAncEndpoints">getAncEndpoints</a></li><li data-type='method'><a href="Client.html#getAncOperationStatus">getAncOperationStatus</a></li><li data-type='method'><a href="Client.html#getAncPolicies">getAncPolicies</a></li><li data-type='method'><a href="Client.html#getAncPolicyByName">getAncPolicyByName</a></li><li data-type='method'><a href="Client.html#getEgressMatrices">getEgressMatrices</a></li><li data-type='method'><a href="Client.html#getEgressPolicies">getEgressPolicies</a></li><li data-type='method'><a href="Client.html#getMdmEndpointByMac">getMdmEndpointByMac</a></li><li data-type='method'><a href="Client.html#getMdmEndpoints">getMdmEndpoints</a></li><li data-type='method'><a href="Client.html#getMdmEndpointsByOs">getMdmEndpointsByOs</a></li><li data-type='method'><a href="Client.html#getMdmEndpointsByType">getMdmEndpointsByType</a></li><li data-type='method'><a href="Client.html#getProfiles">getProfiles</a></li><li data-type='method'><a href="Client.html#getRadiusFailureById">getRadiusFailureById</a></li><li data-type='method'><a href="Client.html#getRadiusFailures">getRadiusFailures</a></li><li data-type='method'><a href="Client.html#getSecurityGroupAcls">getSecurityGroupAcls</a></li><li data-type='method'><a href="Client.html#getSecurityGroups">getSecurityGroups</a></li><li data-type='method'><a href="Client.html#getSessionByIp">getSessionByIp</a></li><li data-type='method'><a href="Client.html#getSessionByMac">getSessionByMac</a></li><li data-type='method'><a href="Client.html#getSessions">getSessions</a></li><li data-type='method'><a href="Client.html#getSxpBindings">getSxpBindings</a></li><li data-type='method'><a href="Client.html#getSystemHealth">getSystemHealth</a></li><li data-type='method'><a href="Client.html#getSystemPerformance">getSystemPerformance</a></li><li data-type='method'><a href="Client.html#getUserGroupByUserName">getUserGroupByUserName</a></li><li data-type='method'><a href="Client.html#getUserGroups">getUserGroups</a></li><li data-type='method'><a href="Client.html#publishEndpointAssetUpdate">publishEndpointAssetUpdate</a></li><li data-type='method'><a href="Client.html#subscribeToAncPolicies">subscribeToAncPolicies</a></li><li data-type='method'><a href="Client.html#subscribeToEndpointAsset">subscribeToEndpointAsset</a></li><li data-type='method'><a href="Client.html#subscribeToGroups">subscribeToGroups</a></li><li data-type='method'><a href="Client.html#subscribeToMdmEndpoints">subscribeToMdmEndpoints</a></li><li data-type='method'><a href="Client.html#subscribeToProfiler">subscribeToProfiler</a></li><li data-type='method'><a href="Client.html#subscribeToRadiusFailures">subscribeToRadiusFailures</a></li><li data-type='method'><a href="Client.html#subscribeToSessions">subscribeToSessions</a></li><li data-type='method'><a href="Client.html#subscribeToSxpBindings">subscribeToSxpBindings</a></li><li data-type='method'><a href="Client.html#subscribeToTrustSecPolicyDownloads">subscribeToTrustSecPolicyDownloads</a></li></ul></li><li><a href="Control.html">Control</a><ul class='methods'><li data-type='method'><a href="Control.html#activate">activate</a></li><li data-type='method'><a href="Control.html#autoServiceReregister">autoServiceReregister</a></li><li data-type='method'><a href="Control.html#getAccessSecret">getAccessSecret</a></li><li data-type='method'><a href="Control.html#serviceLookup">serviceLookup</a></li><li data-type='method'><a href="Control.html#serviceRegister">serviceRegister</a></li><li data-type='method'><a href="Control.html#serviceReregister">serviceReregister</a></li><li data-type='method'><a href="Control.html#serviceUnregister">serviceUnregister</a></li><li data-type='method'><a href="Control.html#serviceUnregisterAll">serviceUnregisterAll</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">control.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const http = require('axios');
const https = require('https');

const ACCOUNT_ACTIVATE_URL = '/AccountActivate';
const SERVICE_LOOKUP_URL = '/ServiceLookup';
const ACCESS_SECRET_URL = '/AccessSecret';
const SERVICE_REGISTER_URL = '/ServiceRegister';
const SERVICE_REREGISTER_URL = '/ServiceReregister';
const SERVICE_UNREGISTER_URL = '/ServiceUnregister';

/**
 * @class Control
 *
 * @description Establishes a PxGrid Control connection. Generally passed to a PxGrid REST Client session.
 * @constructor
 * @param {Object} options Options for the PxGrid Control instance. See examples for more information.
 * @param {string} options.host The IP or URL of the PxGrid Controller.
 * @param {number} [options.port] The host port to connect to the PxGrid Controller on.
 * @param {string} options.client The desired name of the client for the client.
 * @param {Buffer} options.clientCert A byte stream of the client public key certificate file to use.
 * @param {Buffer} options.clientKey A byte stream of the client private key file to use.
 * @param {Buffer} options.caBundle A byte stream of the CA Bundle used to verify the PxGrid Controller's identity.
 * @param {string} [options.clientKeyPassword] The password to unlock the client private key file.
 * @param {string} [options.secret] The secret to help authenticate a newly registered service.
 *
 *
 * @see {@link https://github.com/cisco-pxgrid/pxgrid-rest-ws/wiki/ Cisco PxGrid 2.0 GitHub Wiki} for more information on the Cisco PxGrid 2.0 implementation.
 *
 * @example
 *
 * const fs = require('fs');
 * certs = [];
 * certs.clientCert = fs.readFileSync('./certs/publiccert.cer');
 * certs.clientKey = fs.readFileSync('./certs/key.pem');
 * certs.caBundle = fs.readFileSync('./certs/caBundle.cer');
 *
 * const Pxgrid = require('pxgrid-node');
 *
 * const pxgridControlOptions = {
 *   host: 'my-ise-server.domain.com',
 *   client: 'my-node-app',
 *   clientCert: certs.clientCert,
 *   clientKey: certs.clientKey,
 *   caBundle: certs.caBundle,
 *   clientKeyPassword: false,
 *   secret: '',
 *   port: '8910'
 * }
 *
 * const pxcontrol = new Pxgrid.Control(pxgridControlOptions);
 */

class Control {
  constructor({
    host,
    client,
    clientCert,
    clientKey,
    caBundle,
    clientKeyPassword,
    secret,
    port})
  {
    this.config = {
      hostname: host,
      client: client,
      port: port || '8910',
      secret: secret || '',
      clientCert: clientCert,
      clientKey: clientKey,
      clientKeyPassword: clientKeyPassword || false,
      caBundle: caBundle,
    }

    this.config.baseUrl = 'https://' + this.config.hostname + ':' + this.config.port + '/pxgrid/control'

    this.basicAuth = Buffer.from(this.config.client + ":" + this.config.secret).toString('base64');
    const httpsOptions = {
      cert: this.config.clientCert,
      key: this.config.clientKey,
      ca: this.config.caBundle,
      rejectUnauthorized: false
    };
    if (this.config.clientKeyPassword) httpsOptions.passphrase = clientKeyPassword;

    this.config.session = http.create({
      baseURL: this.config.baseUrl,
      headers: {
        'Authorization': 'Basic ' + this.basicAuth,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      httpsAgent: new https.Agent(httpsOptions)
    });

    this.registeredServices = [];

    if (!this.config.hostname || !this.config.client) {
      throw new Error('Please define hostname and a Pxgrid client name befor connecting to the pxGrid server.');
    }

  }

  _post(url, body, debug=false) {
    return this.config.session.post(url, body)
      .then(response => {
        if (debug) {
          console.debug('URL: ' + url);
          console.debug('DATA: ' + JSON.stringify(response.data));
        }
        return response.data;
      })
      .catch(error => {
        console.log(error);
      });
  }
  /**
   * Activate your client pxGrid account on the controller.
   *
   * If the client is not activated, you will fail to interact with pxGrid.
   *
   * Sometimes, the account will return with a PENDING status which will induce a backoff timer of 60 seconds before retrying. This is normally because the account needs to be activated on the pxGrid Controller (either manually, or automatically). If configured for auto-approval, the activation should work in the next attempt.
   *
   * @param {string} [accountDesc='pxgrid-node'] A description for the client you are registering.
   * @returns {Promise} True if the PxGrid account has been activated on the upstream PxGrid controller.
   * @see {@link https://github.com/cisco-pxgrid/pxgrid-rest-ws/wiki/pxGrid-Consumer#accountactivate Cisco PxGrid 2.0 GitHub Wiki - AccountActivate}
   * @memberof Control
   */
  activate(accountDesc = 'pxgrid-node') {
    const payload = { "description": accountDesc };
    return this._post(ACCOUNT_ACTIVATE_URL, payload)
      .then(response => {
        const state = response.accountState;
        if (state === 'ENABLED') {
          return true;
        } else if (state === 'PENDING') {
          // If state is PENDING, retry in 60 seconds by recursively calling this function.
          console.error('Account state is PENDING. Retrying in 60 seconds. The account may need to be approved on the pxGrid controller.')
          return setTimeout(() => {
            return this.activate(accountDesc);
          }, 60000)
        } else if(state === 'DISABLED') {
          throw new Error('Client failed to activate because the account state is DISABLED! Please enable the account on the pxGrid controller.');
        }
      })
      .catch(error => { throw new Error(error) });
  }

  /**
   * Looks up any nodes providing the serviceName.
   * @memberof Control
   * @param  {string} serviceName Name of the service to lookup.
   * @returns {Promise} Returns a list of nodes providing the specified service, as well as their properties.
   */
  serviceLookup(serviceName) {
    const payload = { "name": serviceName };
    return this._post(SERVICE_LOOKUP_URL, payload)
      .then(response => {
        return response.services[0]
      });
  }

  /**
   * Register as a publisher to a service. This could be a new service, or an existing service.
   * @memberof Control
   * @param  {string} serviceName Name of the service to register for.
   * @param  {Object} properties Properties of the service you are registering.
   * @returns {Promise} The id and reregisterTimeMillis for the newly registered service.
   */
  serviceRegister(serviceName, properties) {
    const payload = { name: serviceName, properties: properties };
    return this._post(SERVICE_REGISTER_URL, payload)
      .then(response => {
        this.registeredServices[serviceName] = response.id;
        return response;
      })
      .catch(error => console.log(error));
  }

  /**
   * Reregister your node for a service. Services must reregister within the reregisterTimeMillis interval provided when initially registering.
   * @memberof Control
   * @see serviceRegister
   * @param  {string} serviceId The ID of the service to reregister.
   * @returns {Promise} Empty response from controller, if successful.
   */
  serviceReregister(serviceId) {
    return this._post(SERVICE_REREGISTER_URL, { id: serviceId });
  }

  /**
   * Automatically reregister a service at a given interval. Reregistration will occur 5 seconds prior to provided interval to prevent inadvertent timeouts.
   * @memberof Control
   * @see {@link serviceReregister}
   * @param {string} serviceId The ID of the service to reregister.
   * @param {number} interval Interval to reregister (milliseconds).
   * @returns nothing
   */
  autoServiceReregister(serviceId, interval) {
    setInterval(() => this.serviceReregister(serviceId), interval-5000);
  }

  /**
   * Unregisters a service.
   * @memberof Control
   * @param {string} serviceId The ID of the service to unregister.
   * @returns {Promise} Empty response from controller, if successful.
   */
  serviceUnregister(serviceId) {
    return this._post(SERVICE_UNREGISTER_URL, { id: serviceId });
  }

  /**
   * Unregisters all services that have been registered by the instance.
   * @memberof Control
   * @returns nothing
   */
  serviceUnregisterAll() {
    this.registeredServices.forEach(service => {
      this.serviceUnregister(service.id)
        .then(response => console.log(response));
    });
  }

  /**
   * Gets the Access Secret for a given node. AccessSecret is a unique secret between a Consumer and Provider pair.
   * @memberof Control
   * @param  {string} nodeName The node name to get the secret for.
   * @returns {Promise} Access Secret for node.
   */
  getAccessSecret(nodeName) {
    const payload = { "peerNodeName": nodeName };
    return this._post(ACCESS_SECRET_URL, payload);
  }

  getConfig() {
    return this.config;
  }
}

module.exports = Control;</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 30 2019 16:41:18 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
