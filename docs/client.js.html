<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>client.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#applyAncToEndpointByIp">applyAncToEndpointByIp</a></li><li data-type='method'><a href="Client.html#applyAncToEndpointByMac">applyAncToEndpointByMac</a></li><li data-type='method'><a href="Client.html#clearAncFromEndpointByIp">clearAncFromEndpointByIp</a></li><li data-type='method'><a href="Client.html#clearAncFromEndpointByMac">clearAncFromEndpointByMac</a></li><li data-type='method'><a href="Client.html#connectToBroker">connectToBroker</a></li><li data-type='method'><a href="Client.html#createAncPolicy">createAncPolicy</a></li><li data-type='method'><a href="Client.html#createEndpointAssetPublisher">createEndpointAssetPublisher</a></li><li data-type='method'><a href="Client.html#deleteAncPolicy">deleteAncPolicy</a></li><li data-type='method'><a href="Client.html#getAncEndpointByMac">getAncEndpointByMac</a></li><li data-type='method'><a href="Client.html#getAncEndpoints">getAncEndpoints</a></li><li data-type='method'><a href="Client.html#getAncOperationStatus">getAncOperationStatus</a></li><li data-type='method'><a href="Client.html#getAncPolicies">getAncPolicies</a></li><li data-type='method'><a href="Client.html#getAncPolicyByName">getAncPolicyByName</a></li><li data-type='method'><a href="Client.html#getEgressMatrices">getEgressMatrices</a></li><li data-type='method'><a href="Client.html#getEgressPolicies">getEgressPolicies</a></li><li data-type='method'><a href="Client.html#getMdmEndpointByMac">getMdmEndpointByMac</a></li><li data-type='method'><a href="Client.html#getMdmEndpoints">getMdmEndpoints</a></li><li data-type='method'><a href="Client.html#getMdmEndpointsByOs">getMdmEndpointsByOs</a></li><li data-type='method'><a href="Client.html#getMdmEndpointsByType">getMdmEndpointsByType</a></li><li data-type='method'><a href="Client.html#getProfiles">getProfiles</a></li><li data-type='method'><a href="Client.html#getRadiusFailureById">getRadiusFailureById</a></li><li data-type='method'><a href="Client.html#getRadiusFailures">getRadiusFailures</a></li><li data-type='method'><a href="Client.html#getSecurityGroupAcls">getSecurityGroupAcls</a></li><li data-type='method'><a href="Client.html#getSecurityGroups">getSecurityGroups</a></li><li data-type='method'><a href="Client.html#getSessionByIp">getSessionByIp</a></li><li data-type='method'><a href="Client.html#getSessionByMac">getSessionByMac</a></li><li data-type='method'><a href="Client.html#getSessions">getSessions</a></li><li data-type='method'><a href="Client.html#getSxpBindings">getSxpBindings</a></li><li data-type='method'><a href="Client.html#getSystemHealth">getSystemHealth</a></li><li data-type='method'><a href="Client.html#getSystemPerformance">getSystemPerformance</a></li><li data-type='method'><a href="Client.html#getUserGroupByUserName">getUserGroupByUserName</a></li><li data-type='method'><a href="Client.html#getUserGroups">getUserGroups</a></li><li data-type='method'><a href="Client.html#publishEndpointAssetUpdate">publishEndpointAssetUpdate</a></li><li data-type='method'><a href="Client.html#subscribeToAncPolicies">subscribeToAncPolicies</a></li><li data-type='method'><a href="Client.html#subscribeToEndpointAsset">subscribeToEndpointAsset</a></li><li data-type='method'><a href="Client.html#subscribeToGroups">subscribeToGroups</a></li><li data-type='method'><a href="Client.html#subscribeToMdmEndpoints">subscribeToMdmEndpoints</a></li><li data-type='method'><a href="Client.html#subscribeToProfiler">subscribeToProfiler</a></li><li data-type='method'><a href="Client.html#subscribeToRadiusFailures">subscribeToRadiusFailures</a></li><li data-type='method'><a href="Client.html#subscribeToSessions">subscribeToSessions</a></li><li data-type='method'><a href="Client.html#subscribeToSxpBindings">subscribeToSxpBindings</a></li><li data-type='method'><a href="Client.html#subscribeToTrustSecPolicyDownloads">subscribeToTrustSecPolicyDownloads</a></li></ul></li><li><a href="Control.html">Control</a><ul class='methods'><li data-type='method'><a href="Control.html#activate">activate</a></li><li data-type='method'><a href="Control.html#autoServiceReregister">autoServiceReregister</a></li><li data-type='method'><a href="Control.html#getAccessSecret">getAccessSecret</a></li><li data-type='method'><a href="Control.html#serviceLookup">serviceLookup</a></li><li data-type='method'><a href="Control.html#serviceRegister">serviceRegister</a></li><li data-type='method'><a href="Control.html#serviceReregister">serviceReregister</a></li><li data-type='method'><a href="Control.html#serviceUnregister">serviceUnregister</a></li><li data-type='method'><a href="Control.html#serviceUnregisterAll">serviceUnregisterAll</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">client.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const http = require('axios');
const https = require('https');
const WebSocket = require('ws');
const StompJs = require('@stomp/stompjs');

const ANC_SERVICE = 'com.cisco.ise.config.anc';
const SESSION_SERVICE = 'com.cisco.ise.session';
const PROFILER_SERVICE = 'com.cisco.ise.config.profiler';
const MDM_SERVICE = 'com.cisco.ise.mdm';
const RADIUS_SERVICE = 'com.cisco.ise.radius';
const SYSTEM_HEALTH_SERVICE = 'com.cisco.ise.system';
const TRUSTSEC_SERVICE = 'com.cisco.ise.trustsec';
const TRUSTSEC_CONFIG_SERVICE = 'com.cisco.ise.config.trustsec';
const TRUSTSEC_SXP_SERVICE = 'com.cisco.ise.sxp';
const PUBSUB_SERVICE = 'com.cisco.ise.pubsub';
const ENDPOINT_ASSET_SERVICE = 'com.cisco.endpoint.asset';

/**
 * @class Client
 *
 * @description Series of functions that allow easy interaction with Cisco PxGrid 2.0 protocol implementation (typically with a Cisco ISE PxGrid Controller).
 * @description PxGrid 2.0 makes use of REST API for push/pull options, and Web Sockets for messaging-style connections.
 * @description The web sockets use a STOMP-based messaging framework.
 * @constructor
 * @param {Object.&lt;Control>} pxgridControl A configured instance of the Control class.
 *
 * @see {@link Control}
 * @see {@link https://github.com/cisco-pxgrid/pxgrid-rest-ws/wiki/ Cisco PxGrid 2.0 GitHub Wiki} for more information on the Cisco PxGrid 2.0 implementation.
 *
 * @example &lt;caption>Control instance setup excluded.&lt;/caption>
 * const Pxgrid = require('pxgrid-node');
 *
 * const pxgrid = new Pxgrid.Control(pxgridControlOptions);
 * const pxclient = new Pxgrid.Client(pxgridControlObject);
 *
 * pxgrid.activate()
 *   .then(() => {
 *     pxclient.getProfiles()
 *        .then(profiles => console.log(profiles));
 *
 *     pxclient.applyAncToEndpointByMac('QUARANTINE', '11:00:00:00:00:01')
 *       .then(response => console.log(response));
 *   });
 *
 * @example &lt;caption>Example including the Control instance setup.&lt;/caption>
 * const fs = require('fs');
 * const Pxgrid = require('pxgrid-node');
 *
 * certs = [];
 * certs.clientCert = fs.readFileSync('./certs/publiccert.cer');
 * certs.clientKey = fs.readFileSync('./certs/key.pem');
 * certs.caBundle = fs.readFileSync('./certs/caBundle.cer');
 *
 * const pxgridControlOptions = {
 *   host: 'my-ise-server.domain.com',
 *   client: 'node-pxgrid',
 *   clientCert: certs.clientCert,
 *   clientKey: certs.clientKey,
 *   caBundle: certs.caBundle,
 *   clientKeyPassword: false,
 * }
 *
 * const pxcontrol = new Pxgrid.Control(pxgridControlOptions);
 * const pxclient = new Pxgrid.Client(pxgridControlObject);
 *
 * pxcontrol.activate()
 *   .then(() => {
 *     pxclient.getProfiles()
 *        .then(profiles => console.log(profiles));
 *
 *     pxclient.applyAncToEndpointByMac('QUARANTINE', '11:00:00:00:00:01')
 *       .then(response => console.log(response));
 *   });
 */

class Client {
  constructor(pxgridControl) {
    this.pxgrid = pxgridControl;
    this.config = this.pxgrid.getConfig();
    this.restSessions = [];
  }

  _post(session, url, payload = {}, debug=false) {
    return session.post(url, payload)
      .then(response => {
        if (debug) {
          console.debug('URL: ' + url);
          console.debug('DATA: ' + response.data);
        }
        return response.data;
      });
  }

  _getServiceInfo(service) {
    return this.pxgrid.serviceLookup(service);
  }

  _getServiceWithSecret(service) {
    let nodeInfo = {};
    return this._getServiceInfo(service)
      .then(service => {
        nodeInfo = service;
        return nodeInfo;
      })
      .then(node => this._getAccessSecret(node.nodeName))
      .then(secret => {
        nodeInfo.secret = secret;
        return nodeInfo;
      })
      .catch(error => console.error(error));
  }

  _getAccessSecret(nodeName) {
    return this.pxgrid.getAccessSecret(nodeName)
      .then(response => response.secret)
      .catch(error => { throw new Error(error) });
  }

  _getRestSession(serviceName, baseUrl, nodeSecret) {
    // Check if we've already created a session for this service to prevent excessive object creation.
    if (this.restSessions[serviceName]) return this.restSessions[serviceName];

    const basicAuth = Buffer.from(this.config.client + ":" + nodeSecret).toString('base64');
    const httpsOptions = {
      cert: this.config.clientCert,
      key: this.config.clientKey,
      ca: this.config.caBundle,
      rejectUnauthorized: false
    };
    if (this.config.clientKeyPassword) httpsOptions.passphrase = this.config.clientKeyPassword;

    const session = http.create({
      baseURL: baseUrl,
      headers: {
        'Authorization': 'Basic ' + basicAuth,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      httpsAgent: new https.Agent(httpsOptions)
    });

    this.restSessions[serviceName] = session;
    return this.restSessions[serviceName];
  }

  _getRest(service) {
    return this._getServiceWithSecret(service)
      .then(service => this._getRestSession(service.name, service.properties.restBaseUrl, service.secret));
  }


  // Pubsub functions
  _getPubsubWebSocket(pubsubService) {
    const basicAuth = Buffer.from(this.config.client + ":" + pubsubService.secret).toString('base64');
    const headers = { 'Authorization': 'Basic ' + basicAuth }
    const socketOptions = {
      cert: this.config.clientCert,
      key: this.config.clientKey,
      ca: this.config.caBundle,
      rejectUnauthorized: false,
      headers: headers
    }
    if (this.config.clientKeyPassword) socketOptions.passphrase = this.config.clientKeyPassword;
    return new WebSocket(pubsubService.properties.wsUrl, socketOptions);
  }

  _getTopicSubscriber(stompClient, topic, messageCallback) {
    const parseAndCallback = function (frame) {
      const message = Object.assign({}, frame)
      if (message.isBinaryBody) {
        message.body = JSON.parse(String.fromCharCode.apply(null, message._binaryBody));
      } else {
        message.body = JSON.parse(message.body);
      }
      messageCallback(message);
    }
    return stompClient.subscribe(topic, parseAndCallback);
  }

  /**
   * Creates a STOMP client over a Web Socket connection to the PxGrid Controller. This returned client object can be passed to subscribe/publish function to enable pub/sub functionality.
   *
   * Returned client must be activated prior to use using client.activate(). This can take a short period of time, so a setTimeout may be required to ensure client was activated before trying to use.
   *
   * This may change in the future for better usage (e.g. wait period executed within connectToBroker()).
   *
   * @param {boolean} [debug=false] Enable debugging of publish/subscribe events going through the broker.
   * @param {number} [waitPeriod=1500] (milliseconds) Period to wait to ensure activation is successful.
   * @returns {Promise} A STOMP client object.
   * @memberof Client
   *
   * @example
   * const ancCallback = function (message) {
   *   const body = JSON.parse(message.body);
   *   console.log("Endpoint " + body.macAddress + " has had an " + body.status + " ANC event");
   * }
   *
   * function main() {
   *   pxclient.connectToBroker()
   *     .then(session => pxclient.subscribeToAncPolicies(session, ancCallback));
   * }
   *
   * pxgrid.activate()
   *   .then(() => main());
   *
   */
  connectToBroker(debug=false) {
    return this._getServiceWithSecret(PUBSUB_SERVICE)
      .then(pubsub => {
        const client = new StompJs.Client({
          webSocketFactory: () => this._getPubsubWebSocket(pubsub),
          debug: str => {
            if(debug) console.log(str);
          },
          forceBinaryWSFrames: true,
          connectHeaders: { host: pubsub.nodeName },
          stompVersions: new StompJs.Versions(['1.2']),
          reconnectDelay: 30000,
          heartbeatIncoming: 4000,
          heartbeatOutgoing: 4000
        });

        client.onConnect = function (frame) {
          // Do something, all subscribes must be done is this callback
          // This is needed because this will be executed after a (re)connect
          console.log("Connected to STOMP broker!");
          console.log("FRAME: " + frame);
        };

        client.onWebSocketClose = function (frame) {
          console.log('Disconnected from STOMP broker!');
        }

        client.onStompError = function (frame) {
          // Will be invoked in case of error encountered at Broker
          // Bad login/passcode typically will cause an error
          // Complaint brokers will set `message` header with a brief message. Body may contain details.
          // Compliant brokers will terminate the connection after any error
          console.log('Broker reported error: ' + frame.headers['message']);
          console.log('Additional details: ' + frame.body);
        };

        return client;
      })
      .then(client => {
        client.activate()
        return client;
      })
      .catch(error => { throw new Error(error) });
  }


  // Session directory functions
  /**
   * Get all active sessions.
   * @memberof Client
   * @returns {Promise} An array of session objects.
   */
  getSessions() {
    return this._getRest(SESSION_SERVICE)
      .then(session => this._post(session, '/getSessions'))
      .then(response => response.sessions);
  }

  /**
   * Get session information for a given IP address.
   * @memberof Client
   * @param {string} ip IP address to lookup session for.
   * @returns {Promise} A session object.
   */
  getSessionByIp(ip) {
    return this._getRest(SESSION_SERVICE)
      .then(session => this._post(session, '/getSessionByIpAddress', { ipAddress: ip }))
      .then(response => response);
  }

  /**
   * Get session information for a given MAC address.
   * @memberof Client
   * @param {string} mac MAC address to lookup session for.
   * @returns {Promise} A session object.
   */
  getSessionByMac(mac) {
    return this._getRest(SESSION_SERVICE)
      .then(session => this._post(session, '/getSessionByMacAddress', { macAddress: mac }))
      .then(response => response);
  }

  /**
   * Gets all user groups.
   * @memberof Client
   * @returns {Promise} An array of group objects.
   */
  getUserGroups() {
    return this._getRest(SESSION_SERVICE)
      .then(session => this._post(session, '/getUserGroups'))
      .then(response => response.userGroups);
  }

  /**
   * Gets all groups a given username is a member of.
   * @memberof Client
   * @param {string} name User name.
   * @returns {Promise} An array of group objects.
   */
  getUserGroupByUserName(name) {
    return this._getRest(SESSION_SERVICE)
      .then(session => this._post(session, '/getUserGroupByUserName', { userName: name }))
      .then(response => response.groups);
  }

  /**
   * Subscribes to the sessions topic.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToSessions(stompClient, messageCallback) {
    return this._getServiceWithSecret(SESSION_SERVICE)
      .then(service => this._getTopicSubscriber(stompClient, service.properties.sessionTopic, messageCallback));
  }

  /**
   * Subscribes to the groups topic.
   *
   * Note: During testing, this subscription did not appear to receive any data from create, update, delete operations on user/endpoint identity groups, or adding/removing users from an identity group.
   *
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToGroups(stompClient, messageCallback) {
    return this._getServiceWithSecret(SESSION_SERVICE)
      .then(service => this._getTopicSubscriber(stompClient, service.properties.groupTopic, messageCallback));
  }

  // Profiler
  /**
   * Get all endpoint profiles.
   * @memberof Client
   * @returns {Promise} An array of endpoint profile objects.
   */
  getProfiles() {
    return this._getRest(PROFILER_SERVICE)
      .then(session => this._post(session, '/getProfiles'))
      .then(response => response.profiles);
  }

  /**
   * Subscribes to the profiles topic.
   *
   * Note: This topic only emits events when an endpoint profile is created or deleted. It doesn't emit anything when an endpoint changes profile.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToProfiler(stompClient, messageCallback) {
    // This topic doesn't appear to emit any data when an endpoint changes profile,
    // or when a profile is created/deleted. Not sure if there's anything being published.
    return this._getServiceWithSecret(PROFILER_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.topic, messageCallback));
  }

  // MDM
  // I don't have MDM integrated with ISE, so unable to fully test some of these.
  /**
   * Gets MDM endpoints.
   * @memberof Client
   * @param {boolean} [filter=false]
   * @see {@link https://github.com/cisco-pxgrid/pxgrid-rest-ws/wiki/MDM#endpoint-object PxGrid MDM Documentation} for endpoint object used for filter.
   * @returns {Promise} An array of MDM endpoint objects.
   */
  getMdmEndpoints(filter = false) {
    let payload = {};
    if (filter) payload.filter = filter;
    return this._getRest(MDM_SERVICE)
      .then(session => this._post(session, '/getEndpoints', payload))
      .then(response => response.endpoints)
      .catch(error => console.error(error));
  }

  /**
   * Gets an MDM endpoints by MAC address.
   * @memberof Client
   * @param {string} mac MAC address of MDM client to retrieve.
   * @returns {Promise} An MDM endpoint object.
   */
  getMdmEndpointByMac(mac) {
    return this._getRest(MDM_SERVICE)
      .then(session => this._post(session, '/getEndpointByMacAddress', { macAddress: mac }))
      .then(response => response)
      .catch(error => console.error(error));
  }

  /**
   * Get an MDM endpoint by type.
   * @memberof Client
   * @param {string} type Value must be 'NON_COMPLIANT', 'REGISTERED', or 'DISCONNECTED'
   * @returns {Promise} An array of MDM endpoint objects.
   */
  getMdmEndpointsByType(type) {
    if (!type) throw new Error('Must specify a type of NON_COMPLIANT, REGISTERED, or DISCONNECTED.');
    return this._getRest(MDM_SERVICE)
      .then(session => this._post(session, '/getEndpointsByType', { type: type }))
      .then(response => response.endpoints)
      .catch(error => console.error(error));
  }

  /**
   * Get an MDM endpoint by OS type.
   * @memberof Client
   * @param {string} osType Value must be 'ANDROID', 'IOS', or 'WINDOWS'.
   * @returns {Promise} An MDM endpoint object.
   */
  getMdmEndpointsByOs(osType) {
    if (!type) throw new Error('Must specify an OS of ANDROID, IOS, or WINDOWS.');
    return this._getRest(MDM_SERVICE)
      .then(session => this._post(session, '/getEndpointsByOsType', { osType: osType }))
      .then(response => response.endpoints)
      .catch(error => console.error(error));
  }

  /**
   * Subscribes to the MDM endpoints topic.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToMdmEndpoints(stompClient, messageCallback) {
    return this._getServiceWithSecret(MDM_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.endpointTopic, messageCallback));
  }

  // Adaptive Network Control (ANC)
  /**
   * Get all ANC policies.
   * @memberof Client
   * @returns {Promise} An array of ANC policy objects.
   */
  getAncPolicies() {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/getPolicies'))
      .then(response => response.policies);
  }

  /**
   * Gets an ANC policy details by name.
   * @memberof Client
   * @param {string} name Name of an existing ANC policy.
   * @returns {Promise} An ANC policy object.
   */
  getAncPolicyByName(name) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/getPolicyByName', { name: name }))
      .then(response => response);
  }

  /**
   * Create a new ANC policy.
   * @memberof Client
   * @param {string} name The name of the new ANC policy.
   * @param {Object} actions Actions must be an array, and there must only be one item in the array. Acceptable values are 'QUARANTINE', 'SHUT_DOWN', 'PORT_BOUNCE'.
   * @returns {Promise} An ANC policy object.
   */
  createAncPolicy(name, actions) {
    if (typeof (actions) !== 'object') throw new Error("'actions' must be an object.");
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/createPolicy', { name: name, actions: actions }))
      .catch(error => { throw new Error(error.response.data.message) });
  }

  /**
   * Deletes an ANC policy.
   * @memberof Client
   * @param {string} name The name of the ANC policy to be deleted.
   * @returns {Promise} empty
   */
  deleteAncPolicy(name) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/deletePolicyByName', { name: name }))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get all endpoints assigned an ANC policy.
   * @memberof Client
   * @returns {Promise} An array of endpoint objects.
   */
  getAncEndpoints() {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/getEndpoints'))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get ANC policy for MAC address.
   * @memberof Client
   * @param {string} mac MAC address of endpoint.
   * @returns {Promise} An ANC endpoint object.
   */
  getAncEndpointByMac(mac) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/getEndpointByMacAddress', { macAddress: mac }))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Apply an ANC policy to an endpoint by MAC address.
   * @memberof Client
   * @param {string} policy The name of the ANC policy to apply.
   * @param {string} mac The MAC address to apply the policy to.
   * @returns {Promise} A status object.
   */
  applyAncToEndpointByMac(policy, mac) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/applyEndpointByMacAddress', { policyName: policy, macAddress: mac}))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Clears an ANC policy from an endpoint by MAC address.
   * @memberof Client
   * @param {string} policy The name of the ANC policy to clear.
   * @param {string} mac The MAC address to clear the policy from.
   * @returns {Promise} A status object.
   */
  clearAncFromEndpointByMac(policy, mac) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/clearEndpointByMacAddress', { policyName: policy, macAddress: mac}))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Apply an ANC policy to an endpoint by IP address.
   * @memberof Client
   * @param {string} policy The name of the ANC policy to apply.
   * @param {string} ip The IP address to apply the policy to.
   * @returns {Promise} A status object.
   */
  applyAncToEndpointByIp(policy, ip) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/applyEndpointByIpAddress', { policyName: policy, ipAddress: ip}))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Clears an ANC policy from an endpoint by IP address.
   * @memberof Client
   * @param {string} policy The name of the ANC policy to clear.
   * @param {string} ip The IP address to clear the policy from.
   * @returns {Promise} A status object.
   */
  clearAncFromEndpointByIp(policy, ip) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/clearEndpointByIpAddress', { policyName: policy, ipAddress: ip}))
      .catch(error => { throw new Error(error) });
  }

  /**
   * The status of an ANC operation.
   * If operation does not exist, HTTP status "204 No content" will be returned.
   * @memberof Client
   * @param {string} id An operation ID.
   * @returns {Promise} A status object.
   */
  getAncOperationStatus(id) {
    return this._getRest(ANC_SERVICE)
      .then(session => this._post(session, '/getOperationStatus', { operationId: id}))
      .catch(error => { throw new Error(error) });
  }

  /**
   * Subscribes to the ANC policy topic. Messages generated for endpoints being applied or cleared from an ANC policy.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */

  subscribeToAncPolicies(stompClient, messageCallback) {
    return this._getServiceWithSecret(ANC_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.statusTopic, messageCallback));
  }

  // RADIUS
  /**
   * Get all RADIUS failures.
   * @memberof Client
   * @param {number} [startTimestamp=false] If not specified, failures from the last hour will be returned.
   * @returns {Promise} An array of failure objects.
   */
  getRadiusFailures(startTimestamp = false) {
    let payload = {};
    if (startTimestamp) payload.startTimestamp = startTimestamp;
    return this._getRest(RADIUS_SERVICE)
      .then(session => this._post(session, '/getFailures', payload))
      .then(response => response.failures)
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get RADIUS failure by ID.
   * @memberof Client
   * @param {string} id Failure ID.
   * @returns {Promise} A failure object.
   */
  getRadiusFailureById(id) {
    return this._getRest(RADIUS_SERVICE)
      .then(session => this._post(session, '/getFailureById', { id: id }))
      .then(response => response)
      .catch(error => { throw new Error(error) });
  }

  /**
   * Subscribes to the RADIUS failures topic.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToRadiusFailures(stompClient, messageCallback) {
    return this._getServiceWithSecret(RADIUS_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.failureTopic, messageCallback));
  }


  // TrustSec
  /**
   * Subscribes to the groups topic.
   *
   * Note: this service only provide status of SGACL downloads via subscription (as of ISE 2.4).
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToTrustSecPolicyDownloads(stompClient, messageCallback) {
    return this._getServiceWithSecret(TRUSTSEC_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.policyDownloadTopic, messageCallback));
  }


  // TrustSec Config
  /**
   * Get all Security Groups (SGTs).
   * @memberof Client
   * @param {string} [id=false]  Returns all if ID not specified.
   * @returns {Promise} An array of security group objects.
   */
  getSecurityGroups(id = false) {
    let payload = {};
    if (id) payload.id = id;
    return this._getRest(TRUSTSEC_CONFIG_SERVICE)
      .then(session => this._post(session, '/getSecurityGroups', payload))
      .then(response => response.securityGroups)
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get all security group ACLs (SGACLs).
   * @memberof Client
   * @param {string} [id=false] Returns all if ID not specified.
   * @returns {Promise} An array of SGACL objects.
   */
  getSecurityGroupAcls(id = false) {
    let payload = {};
    if (id) payload.id = id;
    return this._getRest(TRUSTSEC_CONFIG_SERVICE)
      .then(session => this._post(session, '/getSecurityGroupAcls', payload))
      .then(response => response.securityGroupAcls)
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get all TrustSec egress policies.
   * @memberof Client
   * @returns {Promise} An array of egress policy objects.
   */
  getEgressPolicies() {
    return this._getRest(TRUSTSEC_CONFIG_SERVICE)
      .then(session => this._post(session, '/getEgressPolicies'))
      .then(response => response.egressPolicies)
      .catch(error => { throw new Error(error) });
  }

  /**
   * Get all TrustSec egress matrices.
   * @memberof Client
   * @returns {Promise} An array of egress matrix objects.
   */
  getEgressMatrices() {
    return this._getRest(TRUSTSEC_CONFIG_SERVICE)
      .then(session => this._post(session, '/getEgressMatrices'))
      .then(response => response.egressMatrices)
      .catch(error => { throw new Error(error) });
  }


  subscribeToSecurityGroups(stompClient, messageCallback) {
    return this._getServiceWithSecret(TRUSTSEC_CONFIG_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.securityGroupTopic, messageCallback));
  }


  // TrustSec SXP
  /**
   * Get all TrustSec SXP bindings.
   *
   * Note: Results are only returned for IP SGT Static Mapping, and only if an SXP device is configured with the SXP service enabled. Otherwise, nothing is returned (even if mappings are configured).
   *
   * @memberof Client
   * @returns {Promise} An array of SXP binding objects.
   */
  getSxpBindings() {
    return this._getRest(TRUSTSEC_SXP_SERVICE)
      .then(session => this._post(session, '/getBindings'))
      .then(response => response.bindings);
  }

  /**
   * Subscribes to the SXP bindings topic.
   *
   * Note: During testing, this topic did not emit any events for new SXP bindings (IP-SGT Mappings) or new SXP connections.
   *
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToSxpBindings(stompClient, messageCallback) {
    return this._getServiceWithSecret(TRUSTSEC_SXP_SERVICE)
    .then(service => this._getTopicSubscriber(stompClient, service.properties.bindingTopic, messageCallback));
  }


  // System health functions
  /**
   * Get system health events.
   * @memberof Client
   *
   * @param {Object} options Options for filtering the system health events.
   * @param {string} [options.nodeName] The name of the node to get system health for. Will return all nodes if nodeName not specified.
   * @param {ISO8601Datetime} [options.startTimestamp] The timestamp to begin getting events with. Will return last hour if startTimestamp not specified.
   * @returns {Promise} An array of system health objects.
   */
  getSystemHealth(options = { nodeName: false, startTimestamp: false }) {
    let payload = {};
    if (options.nodeName) payload.nodeName = options.nodeName;
    if (options.startTimestamp) payload.startTimestamp = options.startTimestamp;
    return this._getRest(SYSTEM_HEALTH_SERVICE)
      .then(session => this._post(session, '/getHealths', payload))
      .then(response => response.healths);
  }

  /**
   * Get system performance events.
   * @memberof Client
   * @param {Object} options Options for filtering the system performance.
   * @param {string} [options.nodeName] The name of the node to get system performance for. Will return all nodes if nodeName not specified.
   * @param {ISO8601Datetime} [options.startTimestamp] The timestamp to begin getting events with. Will return last hour if startTimestamp not specified.
   * @returns {Promise} An array of system performance objects.
   */
  getSystemPerformance(options = { nodeName: false, startTimestamp: false }) {
    let payload = {};
    if (options.nodeName) payload.nodeName = options.nodeName;
    if (options.startTimestamp) payload.startTimestamp = options.startTimestamp;

    return this._getRest(SYSTEM_HEALTH_SERVICE)
      .then(session => this._post(session, '/getPerformances', payload))
      .then(response => response.performances);
  }


  // Endpoint Asset Context-In
  /**
   * Creates a publisher for the Endpoint Asset service. This also registers the client as a publisher for the topic with the controller.
   * @memberof Client
   * @returns {Promise} A status object.
   */
  createEndpointAssetPublisher() {
    const properties = {
      "wsPubsubService": "com.cisco.ise.pubsub",
      "assetTopic": "/topic/" + ENDPOINT_ASSET_SERVICE
    }

    return this.pxgrid.serviceRegister(ENDPOINT_ASSET_SERVICE, properties)
      .then(response => {
        this.pxgrid.autoServiceReregister(response.id, response.reregisterTimeMillis);
        return response;
      });
  }

  /**
   * Publish an endpoint asset update.
   *
   * This allows the addition of attributes from the IOTAsset dictionary, as well as any pre-configured custom attributes, into the endpoint.
   *
   * Note: The Cisco ISE pxGrid Profiler Probe must be enabled for this published event to be processed by ISE. This is not on by default.
   *
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {Object} assetBody A JSON object of asset information to publish to an endpoint.
   * @param {string} assetBody.assetMacAddress MAC address of endpoint.
   * @param {string} assetBody.assetId Arbitrary value.
   * @param {string} assetBody.assetName Arbitrary value.
   * @param {string} assetBody.assetHwRevision Arbitrary value.
   * @param {string} assetBody.assetProtocol Arbitrary value.
   * @param {string} assetBody.assetVendor Arbitrary value.
   * @param {string} assetBody.assetSwRevision Arbitrary value.
   * @param {string} assetBody.assetProductId Arbitrary value.
   * @param {string} assetBody.assetSerialNumber Arbitrary value.
   * @param {string} assetBody.assetDeviceType Arbitrary value.
   * @param {string} assetBody.assetIpAddress Arbitrary value.
   * @param {string} assetBody.assetCustomAttributes Arbitrary value.
   * @param {string} assetBody.assetConnectedLinks Arbitrary value.
   * @param {Object} assetBody.assetConnectedAttributes Any other custom attributes that have been created in Cisco ISE.
   * @param {string} assetBody.assetCustomAttributes.attrName attrName should match name of custom attribute in ISE. Value is arbitrary.
   * @param {boolean} [debug=false] If true, will enable debug messages being logged to console.
   * @memberof Client
   */
  publishEndpointAssetUpdate(stompClient, assetBody, debug=false) {
    let binaryData;
    let data;
    if (assetBody) {
      data = { "opType": "UPDATE", "asset": assetBody }
      if (debug) {
        console.log("DATA TO BE SENT: ");
        console.log(data);
      }
      binaryData = new TextEncoder().encode(JSON.stringify(data));
    } else throw new Error('No body provided to publish.');

    if (this.endpointAssetService) {
      stompClient.publish({
        destination: this.endpointAssetService.assetTopic,
        binaryBody: binaryData,
      });
    } else {
      this._getServiceWithSecret(ENDPOINT_ASSET_SERVICE)
        .then(service => {
          this.endpointAssetService = service;
          stompClient.publish({
            destination: '/topic/' + ENDPOINT_ASSET_SERVICE,
            binaryBody: binaryData,
          });
        });
    }
  }

  /**
   * Subscribes to the Endpoint Asset topic.
   * @memberof Client
   * @param {Object.&lt;stompClient>} stompClient The active broker session to use for subscription.
   * @param {function(messageObject)} messageCallback - A callback function that handles the message coming in on a topic subscription.
   * @returns {Promise} A stomp subscriber object.
   */
  subscribeToEndpointAsset(stompClient, messageCallback) {
    return this._getServiceWithSecret(ENDPOINT_ASSET_SERVICE)
      .then(service => this._getTopicSubscriber(stompClient, service.properties.assetTopic, messageCallback));
  }

  // Subscribe to all topics
  subscribeToAllTopics(stompClient, messageCallback) {
    this.subscribeToAncPolicies(stompClient, messageCallback);
    this.subscribeToEndpointAsset(stompClient, messageCallback);
    this.subscribeToGroups(stompClient, messageCallback);
    this.subscribeToMdmEndpoints(stompClient, messageCallback);
    this.subscribeToProfiler(stompClient, messageCallback);
    this.subscribeToRadiusFailures(stompClient, messageCallback);
    this.subscribeToSecurityGroups(stompClient, messageCallback);
    this.subscribeToSessions(stompClient, messageCallback);
    this.subscribeToSxpBindings(stompClient, messageCallback);
    this.subscribeToTrustSecPolicyDownloads(stompClient, messageCallback);
  }
}
module.exports = Client;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 30 2019 17:50:56 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
